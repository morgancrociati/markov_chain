#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <fstream>
#include <cassert>

#include "markov_chain_int.hpp"

// ----- PUBLIC -----
markov_chain_int::markov_chain_int(unsigned int seed)
{
    sumStartMatrix = 0;
    if (seed == 0)
        srand(time(NULL));
    else
        srand(seed);
}

markov_chain_int::~markov_chain_int()
{
}

void markov_chain_int::add_state(MARKOV_TYPE state, MARKOV_INT start)
{
    assert(find(state) == -1);
    stateNameMatrix.push_back(state);
    MARKOV_INT matrixSize = stateNameMatrix.size();

    for (MARKOV_INT i = 0; i < matrixSize - 1; i++)
        matrix[i].push_back(0);
    
    matrix.push_back(std::vector<MARKOV_INT>(matrixSize, 0));
    sumMatrix.push_back(0);

    startMatrix.push_back(start);
    sumStartMatrix += start;
}

void markov_chain_int::set_transition(MARKOV_TYPE stateFrom, MARKOV_TYPE stateTo, MARKOV_INT n){
    MARKOV_INT iStateFrom = find(stateFrom);
    assert(iStateFrom != -1);
    MARKOV_INT iStateTo = find(stateTo);
    assert(iStateTo != -1);
    
    sumMatrix[iStateFrom] -= matrix[iStateFrom][iStateTo];
    matrix[iStateFrom][iStateTo] = n;
    sumMatrix[iStateFrom] += n;
}

void markov_chain_int::add_sample(std::vector<MARKOV_TYPE> tab)
{
    MARKOV_INT i;
    MARKOV_INT state = -1;
    MARKOV_INT nextState = -1;
    MARKOV_TYPE tmp;

    //For loop iterating over all the element of our vector
    for (std::vector<MARKOV_TYPE>::iterator it = tab.begin(); it != tab.end(); it++)
    {
        tmp = *it;
        nextState = find(tmp);

        if (nextState == -1) //This state was not found in the current markov chain
        {
            add_state(tmp);
            nextState = stateNameMatrix.size() - 1;
        }

        if (state != -1) //Not the first element of the sample
        {
            matrix[state][nextState]++;
            sumMatrix[state]++;
        }
        else //First element of the sample
        {
            startMatrix[nextState]++;
            sumStartMatrix++;
        }

        state = nextState;
    }
}

std::vector<MARKOV_TYPE> markov_chain_int::generate(MARKOV_INT size)
{
    std::vector<MARKOV_TYPE> result;

    MARKOV_INT i;

    MARKOV_INT state = -1;

    //Get the first MARKOV_TYPE generated by our markov chain
    state = get_start();
    result.push_back(stateNameMatrix[state]);
    for (i = 0; i < size - 1; i++)
    {
        if (sumMatrix[state] == 0)
        {
            state = get_start();
            result.push_back(stateNameMatrix[state]);
        }
        else
        {
            state = get_next(state);
            result.push_back(stateNameMatrix[state]);
        }
    }

    return result;
}

void markov_chain_int::write_markov_chain(std::string filePath)
{
    MARKOV_INT i, j;
    MARKOV_INT sizeMatrix = stateNameMatrix.size();
    std::ofstream file;
    file.open(filePath);
    file << sizeMatrix << std::endl;
    for (i = 0; i < sizeMatrix; i++)
        file << stateNameMatrix[i] << " " << startMatrix[i] << std::endl;
    for (i = 0; i < sizeMatrix; i++)
    {
        for (j = 0; j < sizeMatrix; j++)
            file << matrix[i][j] << " ";
        file << std::endl;
    }
    file.close();
}

void markov_chain_int::read_markov_chain(std::string filePath)
{
    MARKOV_INT tmp, numberOfState, i, startInt, endInt, transition;
    std::string line;
    std::ifstream file;
    file.open(filePath);
    std::getline(file, line);
    numberOfState = string_2_markov_int(line);
    for (i = 0; i < numberOfState; i++)
    {
        std::getline(file, line);
        endInt = 0;
        while(line[endInt] != ' ')
            endInt++;
        add_state(string_2_markov_int(line, 0, endInt), string_2_markov_int(line, endInt));
    }
    for (i = 0; i < numberOfState; i++)
    {
        std::getline(file, line);
        startInt = 0;
        endInt = 0;
        transition = 0;
        while(transition < numberOfState - 1){
            while(line[endInt] != ' ')
                endInt++;
            set_transition(stateNameMatrix[i], stateNameMatrix[transition], string_2_markov_int(line, startInt, endInt));
            endInt++;
            startInt = endInt;
            transition++;
        }
        set_transition(stateNameMatrix[i], stateNameMatrix[transition], string_2_markov_int(line, startInt));
    }
    file.close();
}

// ----- PRIVATE -----
MARKOV_INT markov_chain_int::get_start(void)
{
    MARKOV_INT i;
    MARKOV_INT sizeMatrix = stateNameMatrix.size();
    double r = ((double)rand()) / ((double)RAND_MAX);
    double tmp = 0;
    for (i = 0; i < sizeMatrix; i++)
    {
        tmp += ((double)startMatrix[i]) / ((double)sumStartMatrix);
        if (tmp >= r || i == sizeMatrix - 1)
            return i;
    }
    return -1;
}

MARKOV_TYPE markov_chain_int::get_next(MARKOV_INT state)
{
    MARKOV_INT i;
    MARKOV_INT sizeMatrix = stateNameMatrix.size();
    double r = ((double)rand()) / ((double)RAND_MAX);
    double tmp = 0;
    for (i = 0; i < sizeMatrix; i++)
    {
        tmp += ((double)matrix[state][i]) / ((double)sumMatrix[state]);
        if (tmp >= r || i == sizeMatrix - 1)
            return i;
    }
    return -1;
}

MARKOV_INT markov_chain_int::find(MARKOV_TYPE element)
{
    MARKOV_INT i;
    MARKOV_INT sizeMatrix = stateNameMatrix.size();

    for (i = 0; i < sizeMatrix; i++)
    {
        if (stateNameMatrix[i] == element)
        {
            return i;
        }
    }
    return -1;
}

MARKOV_INT markov_chain_int::string_2_markov_int(std::string s, MARKOV_INT startPos, MARKOV_INT endPos)
{
    MARKOV_INT number = 0;
    MARKOV_INT sizeString = (endPos == -1) ? s.size() : endPos;
    assert(0 <= startPos && startPos < sizeString);
    assert((endPos == -1) || (0 <= endPos && endPos <= sizeString));
    assert((endPos == -1) || (endPos >= startPos));
    MARKOV_INT i;
    for (i = startPos; i < sizeString; i++)
    {
        if ('0' <= s[i] && s[i] <= '9')
            number = number * 10 + (s[i] - '0');
    }
    return number;
}